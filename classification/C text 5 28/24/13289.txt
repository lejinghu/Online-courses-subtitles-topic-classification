上面两个程序的唯一区别是左边的程序将局部变量定义成了自动变量，而右边的程序 将局部变量定义成了静态变量。左边程序中的局部变量j在每次调用函数fimc时都要赋初 值，因此每次执行fimc时都会输出1,其结果就是1 1 1 1 1;而右边的程序中的局部变量 j是静态局部变量，调用func之前已经被赋初值为0,调用fane时不会重新赋初值，并且 当函数fUnc返回时，j会保持现有的值。因此第一次调用fbnc时输出1，第二次调用fimc 前，j的值己经是1 了，因此第二次调用func函数输出2,依此类推，其结果就是1 2 34 5。 2)静态全局变量
运行结果：	运行结果：
11111	1 2 3 4 5
全局变量(外部变量)的说明之前再冠以static就构成了静态的全局变量。全局变量本身 就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。 这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组 成时，非静态的全局变量在各个源文件中通过外部变量说明都是有效的。而静态全局变量 则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不 能通过外部变量说明来使用它。由于静态全局变量的作用域局限于一个源文件内，只能为 该源文件内的函数公用，因此可以避免在其他源文件中引起错误。
从以上分析可以看出，把局部变量改变为静态变量是改变了它的存储方式，即改变了 它的生存期。把全局变量改变为静态变量是改变了它的作用域，限制了它的使用范围。因 此static这个说明符在不同的地方所起的作用是不同的。应予以注意。
上面两个程序的唯一区别是左边的程序将局部变量定义成了自动变量，而右边的程序 将局部变量定义成了静态变量。左边程序中的局部变量j在每次调用函数fimc时都要赋初 值，因此每次执行fimc时都会输出1,其结果就是1 1 1 1 1;而右边的程序中的局部变量 j是静态局部变量，调用func之前已经被赋初值为0,调用fane时不会重新赋初值，并且 当函数fUnc返回时，j会保持现有的值。因此第一次调用fbnc时输出1，第二次调用fimc 前，j的值己经是1 了，因此第二次调用func函数输出2,依此类推，其结果就是1 2 34 5。 2)静态全局变量
运行结果：	运行结果：
11111	1 2 3 4 5
全局变量(外部变量)的说明之前再冠以static就构成了静态的全局变量。全局变量本身 就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。 这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组 成时，非静态的全局变量在各个源文件中通过外部变量说明都是有效的。而静态全局变量 则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不 能通过外部变量说明来使用它。由于静态全局变量的作用域局限于一个源文件内，只能为 该源文件内的函数公用，因此可以避免在其他源文件中引起错误。
从以上分析可以看出，把局部变量改变为静态变量是改变了它的存储方式，即改变了 它的生存期。把全局变量改变为静态变量是改变了它的作用域，限制了它的使用范围。因 此static这个说明符在不同的地方所起的作用是不同的。应予以注意。
