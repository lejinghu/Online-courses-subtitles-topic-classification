#细心的读者也许会说：即使f_max和f_min在第10位就出错，但是其偏差值小于10的 31次方，而d_max和d_min实际的偏差值比10的4900次方还大；因此，double型精 确度远不如float型。这个问题是浮点型的存储方式导致的，在讨论浮点型的有效位数 时，不需要考虑它的指数，因为在浮点型的存储中，两者是分开的。	>
ld_max_e = inf ld_min_e = -inf
【代码解析】在本范例中可以清楚地看到，不同浮点数据类型有效数字的差别。但是，在 这个例子中d_max和d_min正确的位数只有4位，而f_max和f_min正确的位数却有9位，这 并不意味着后_者没有前^准确。前者的正确位数少，是-于它的秦17位错误而导致的（少了 1, 也有可能是18位少了 2),而后者在第10位就出现偏差。因此，仍可得出结论：double型的精 确度比float型高。所以在处理浮点型时，不应盲目相信正确位数，而应关注精确度。
4.3.6存储方式
浮点型的存储方式和其他类型有很大不同，而不同编译器之间也存在差别，但大部分都遵 从IEEE数值标准。下面以Linux下的GCC 3.2.2的实现为例，讨论浮点型的存储方式。
#细心的读者也许会说：即使f_max和f_min在第10位就出错，但是其偏差值小于10的 31次方，而d_max和d_min实际的偏差值比10的4900次方还大；因此，double型精 确度远不如float型。这个问题是浮点型的存储方式导致的，在讨论浮点型的有效位数 时，不需要考虑它的指数，因为在浮点型的存储中，两者是分开的。	>
ld_max_e = inf ld_min_e = -inf
【代码解析】在本范例中可以清楚地看到，不同浮点数据类型有效数字的差别。但是，在 这个例子中d_max和d_min正确的位数只有4位，而f_max和f_min正确的位数却有9位，这 并不意味着后_者没有前^准确。前者的正确位数少，是-于它的秦17位错误而导致的（少了 1, 也有可能是18位少了 2),而后者在第10位就出现偏差。因此，仍可得出结论：double型的精 确度比float型高。所以在处理浮点型时，不应盲目相信正确位数，而应关注精确度。
4.3.6存储方式
浮点型的存储方式和其他类型有很大不同，而不同编译器之间也存在差别，但大部分都遵 从IEEE数值标准。下面以Linux下的GCC 3.2.2的实现为例，讨论浮点型的存储方式。
