问题出在浮点数并不是百分之百精确的。比如，浮点型值0.1很接近于数学上的分数1/10, 但它们并不精确地相等。每当下标变量x加0.1时，误差就被累计，到最后与2.0比较来决定是 否结束循环时，x的值可能就成了2.000000001或类似的不是小于或等于2.0的数。这样，for 循环的条件不满足，则它在少运行一个周期的情况下就退出了。解决这个问题的最好方法就 是限制只能用整型作为for循环的变量。因为整型是精确的，不会造成上述问题。

注意，从循环控制看来本应显示的值2.0丢失了。
假如一定要从1.0起累加0.1到2.0,可以采用从10累加1到20,再将它除以10:
for (i=10; i<=20； i++)	{
问题出在浮点数并不是百分之百精确的。比如，浮点型值0.1很接近于数学上的分数1/10, 但它们并不精确地相等。每当下标变量x加0.1时，误差就被累计，到最后与2.0比较来决定是 否结束循环时，x的值可能就成了2.000000001或类似的不是小于或等于2.0的数。这样，for 循环的条件不满足，则它在少运行一个周期的情况下就退出了。解决这个问题的最好方法就 是限制只能用整型作为for循环的变量。因为整型是精确的，不会造成上述问题。

注意，从循环控制看来本应显示的值2.0丢失了。
假如一定要从1.0起累加0.1到2.0,可以采用从10累加1到20,再将它除以10:
for (i=10; i<=20； i++)	{
问题出在浮点数并不是百分之百精确的。比如，浮点型值0.1很接近于数学上的分数1/10, 但它们并不精确地相等。每当下标变量x加0.1时，误差就被累计，到最后与2.0比较来决定是 否结束循环时，x的值可能就成了2.000000001或类似的不是小于或等于2.0的数。这样，for 循环的条件不满足，则它在少运行一个周期的情况下就退出了。解决这个问题的最好方法就 是限制只能用整型作为for循环的变量。因为整型是精确的，不会造成上述问题。

注意，从循环控制看来本应显示的值2.0丢失了。
假如一定要从1.0起累加0.1到2.0,可以采用从10累加1到20,再将它除以10:
for (i=10; i<=20； i++)	{
