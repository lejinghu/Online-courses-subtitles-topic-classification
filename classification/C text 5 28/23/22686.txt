尽管Kemighan和Ritchie认为自增操作比直接加1更有效率(K&R2,第18页)，似R前 所使用的当代编译器通常在这方面都做得很好，使这几种方法的速度都一样。如果没有任何 能够显示它们之间E别的相关上下文环境，现代的C编译器在编译这些语句时应该产生相同 的指令。它们应该是增加一个变量时最快的一种指令。你可以在喜欢的编译器上编译这畔代 码，编译器应该有一个选项，可以产生一个汇编指令列表。你也可以把编译器设置为调试模 式，这样也常常可以使检查对应的C语句和汇编指令更为容易。不要使用优化选项，W为这
mango [i + +] - mango [ i-f + ] + y;
以前，当我们对一些申请Sun的Pascal编译器队伍的位置的候选人进行面试时，最好的 那位候选人(他最终获得了这个工作——嗨！ Arindam)解释说这些E别与编译器的中间代码有 关，例如表示取x的地址，增加它的内容，然后把值放在寄存器中：则表示取 x的地址，把它的值装入寄存器中，然后增加内存中的x的值。顺便问一句，使用编译器的 术语，另外两条语句应该怎么描述？
些语句有可能因为优化而被精简掉。在Sim的工作站中，附上神奇的魔咒“-S”，使命令行看 上去如下：
cc 一S -Xc banana.c
尽管Kemighan和Ritchie认为自增操作比直接加1更有效率(K&R2,第18页)，似R前 所使用的当代编译器通常在这方面都做得很好，使这几种方法的速度都一样。如果没有任何 能够显示它们之间E别的相关上下文环境，现代的C编译器在编译这些语句时应该产生相同 的指令。它们应该是增加一个变量时最快的一种指令。你可以在喜欢的编译器上编译这畔代 码，编译器应该有一个选项，可以产生一个汇编指令列表。你也可以把编译器设置为调试模 式，这样也常常可以使检查对应的C语句和汇编指令更为容易。不要使用优化选项，W为这
mango [i + +] - mango [ i-f + ] + y;
以前，当我们对一些申请Sun的Pascal编译器队伍的位置的候选人进行面试时，最好的 那位候选人(他最终获得了这个工作——嗨！ Arindam)解释说这些E别与编译器的中间代码有 关，例如表示取x的地址，增加它的内容，然后把值放在寄存器中：则表示取 x的地址，把它的值装入寄存器中，然后增加内存中的x的值。顺便问一句，使用编译器的 术语，另外两条语句应该怎么描述？
些语句有可能因为优化而被精简掉。在Sim的工作站中，附上神奇的魔咒“-S”，使命令行看 上去如下：
cc 一S -Xc banana.c
