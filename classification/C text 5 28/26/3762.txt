把主体解释为字符型字符串时，预处理器用4 * 8替换EIGHT.也就是说，额外的空格 也当作替换文本的一部分.但是，当把主体解释为语言符号类型时，预处理器用单个空 格分隔的三个语言符号，即4 * 8来替换同EIGHT.换句话说，用字符型字符串的观点 看，空格也是主体的一部分；而用语言符号字符串的观点看，空格只是分隔主体中语言 符号的符号.在实际应用中，有些C编译器把宏主体当作字符串而非语言符号.抵匕这 个实例更复杂的情况下,字符与语言符号之间的差异才有实际意义.
在处理主体中的多个空格时，字符型字符串和语言符号类型字符串采用不同方法.考虑 下面的定义：
#define EIGHT 4 * 8
顺便提一下,C编译器处理语言符号的方式比预处理器的处理方式更加复杂.编译器 能理解C的规则，不需要用空格来分隔语言符号.例如，C编译器把2 * 2当作三个语 言符号.原因是C编译器认为每个2都是一个常量，而*是一个运算符.
16.2.2重定义常量
把主体解释为字符型字符串时，预处理器用4 * 8替换EIGHT.也就是说，额外的空格 也当作替换文本的一部分.但是，当把主体解释为语言符号类型时，预处理器用单个空 格分隔的三个语言符号，即4 * 8来替换同EIGHT.换句话说，用字符型字符串的观点 看，空格也是主体的一部分；而用语言符号字符串的观点看，空格只是分隔主体中语言 符号的符号.在实际应用中，有些C编译器把宏主体当作字符串而非语言符号.抵匕这 个实例更复杂的情况下,字符与语言符号之间的差异才有实际意义.
在处理主体中的多个空格时，字符型字符串和语言符号类型字符串采用不同方法.考虑 下面的定义：
#define EIGHT 4 * 8
顺便提一下,C编译器处理语言符号的方式比预处理器的处理方式更加复杂.编译器 能理解C的规则，不需要用空格来分隔语言符号.例如，C编译器把2 * 2当作三个语 言符号.原因是C编译器认为每个2都是一个常量，而*是一个运算符.
16.2.2重定义常量
